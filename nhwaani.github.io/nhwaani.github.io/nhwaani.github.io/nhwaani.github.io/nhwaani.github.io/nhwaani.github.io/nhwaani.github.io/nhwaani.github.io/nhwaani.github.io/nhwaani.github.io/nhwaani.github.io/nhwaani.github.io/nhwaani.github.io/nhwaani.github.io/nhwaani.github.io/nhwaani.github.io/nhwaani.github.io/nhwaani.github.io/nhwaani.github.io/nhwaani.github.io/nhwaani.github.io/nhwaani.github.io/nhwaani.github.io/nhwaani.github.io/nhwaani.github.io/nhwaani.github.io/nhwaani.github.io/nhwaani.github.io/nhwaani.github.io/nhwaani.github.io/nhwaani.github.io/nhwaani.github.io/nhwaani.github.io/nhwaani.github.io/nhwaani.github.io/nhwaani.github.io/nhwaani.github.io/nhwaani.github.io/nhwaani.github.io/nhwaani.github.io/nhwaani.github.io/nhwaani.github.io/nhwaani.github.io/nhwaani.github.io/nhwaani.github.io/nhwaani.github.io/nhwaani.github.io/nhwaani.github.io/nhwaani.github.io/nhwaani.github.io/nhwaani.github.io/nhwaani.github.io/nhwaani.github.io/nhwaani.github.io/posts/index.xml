<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Nadeem Hilal</title>
        <link>https://nhwaani.github.io/posts/</link>
        <description>Recent content in Posts on Nadeem Hilal</description>
        <generator>Hugo -- gohugo.io</generator>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Tue, 30 Jun 2020 00:48:21 +0400</lastBuildDate>
        <atom:link href="https://nhwaani.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Review the Pragmatic Programmer</title>
            <link>https://nhwaani.github.io/posts/2020/06/review-the-pragmatic-programmer/</link>
            <pubDate>Tue, 30 Jun 2020 00:48:21 +0400</pubDate>
            
            <guid>https://nhwaani.github.io/posts/2020/06/review-the-pragmatic-programmer/</guid>
            <description>Today i decided to add my review about one of the best books among the software engineers, its a must to have in your bookshelf. The book was written by Dave Thomas and Andy Hunt , and the motto of the book was
YOUR JOURNEY TO MASTERY. This book starts with simple yet profound message
 ITS YOUR LIFE
 It reminds us of our own power in our code-base, jobs , careers. Why this book is different then other books is that it understands what it means to be a programmer. As a relative newcommer, its easy to be overwhelmed not by the act of programming but the process of becoming a programmer.
There is an entire mindset shift that needs to happen &amp;ndash; c changed in the habbits, behaviours, and expectations. The book says that the process of becoming the better programmer does not just happen because
 you know how to code ; It must be met with intention and delibrate practice
 And believe me this book teach it best.
Just a quick reminder, i will be reviewing thier 20th Edition as it the updated edition that came out recently &amp;hellip;</description>
            <content type="html"><![CDATA[<p>Today i decided to add my review about one of the best books among the software engineers, its a must to have in your bookshelf.
The book was written by <strong>Dave Thomas and Andy Hunt</strong> , and the motto of the book was</p>
<h2 id="_your-journey-to-mastery_"><strong><em>YOUR JOURNEY TO MASTERY</em></strong>.</h2>
<p>This book starts with simple yet profound message</p>
<blockquote>
<p>ITS YOUR LIFE</p>
</blockquote>
<p>It reminds us of our own <strong>power</strong> in our <strong>code-base</strong>, <strong>jobs</strong> , <strong>careers</strong>.
Why this book is different then other books is that it understands what it means to be a programmer.
As a relative newcommer, its easy to be overwhelmed not by the act of programming but the process of
becoming a programmer.</p>
<p>There is an entire mindset shift that needs to happen &ndash; c changed in the habbits, behaviours, and
expectations.
The book says that the process of becoming the better programmer does not just happen because</p>
<blockquote>
<p>you know how to code ; It must be met with <strong>intention</strong> and <strong>delibrate practice</strong></p>
</blockquote>
<p>And believe me this book teach it best.</p>
<p>Just a quick reminder, i will be reviewing thier <strong>20th Edition</strong> as it the updated edition that came out recently &hellip;</p>
]]></content>
        </item>
        
        <item>
            <title>Write Code That Is Easy to Delete</title>
            <link>https://nhwaani.github.io/posts/2020/04/write-code-that-is-easy-to-delete/</link>
            <pubDate>Sat, 04 Apr 2020 00:14:21 +0400</pubDate>
            
            <guid>https://nhwaani.github.io/posts/2020/04/write-code-that-is-easy-to-delete/</guid>
            <description>“Every line of code is written without reason, maintained out of weakness, and deleted by chance” Jean-Paul Sartre’s Programming in ANSI C.
 Every line of code written comes at a price: maintenance. To avoid paying for a lot of code, we build reusable software. The problem with code re-use is that it gets in the way of changing your mind later on.
The more consumers of an API you have, the more code you must rewrite to introduce changes. Similarly, the more you rely on an third-party api, the more you suffer when it changes. Managing how the code fits together, or which parts depend on others, is a significant problem in large scale systems, and it gets harder as your project grows older.
 My point today is that, if we wish to count lines of code, we should not regard them as “lines produced” but as “lines spent” EWD 1036
 If we see ‘lines of code’ as ‘lines spent’, then when we delete lines of code, we are lowering the cost of maintenance. Instead of building re-usable software, we should try to build disposable software.
I don’t need to tell you that deleting code is more fun than writing it.</description>
            <content type="html"><![CDATA[<blockquote>
<p>“Every line of code is written without reason, maintained out of weakness, and deleted by chance” Jean-Paul Sartre’s Programming in ANSI C.</p>
</blockquote>
<p>Every line of code written comes at a price: maintenance. To avoid paying for a lot of code, we build reusable software. The problem with code re-use is that it gets in the way of changing your mind later on.</p>
<p>The more consumers of an API you have, the more code you must rewrite to introduce changes. Similarly, the more you rely on an third-party api, the more you suffer when it changes. Managing how the code fits together, or which parts depend on others, is a significant problem in large scale systems, and it gets harder as your project grows older.</p>
<blockquote>
<p>My point today is that, if we wish to count lines of code, we should not regard them as “lines produced” but as “lines spent” EWD 1036</p>
</blockquote>
<p>If we see ‘lines of code’ as ‘lines spent’, then when we delete lines of code, we are lowering the cost of maintenance. Instead of building re-usable software, we should try to build disposable software.</p>
<p>I don’t need to tell you that deleting code is more fun than writing it.</p>
<p>To write code that’s easy to delete: repeat yourself to avoid creating dependencies, but don’t repeat yourself to manage them. Layer your code too: build simple-to-use APIs out of simpler-to-implement but clumsy-to-use parts. Split your code: isolate the hard-to-write and the likely-to-change parts from the rest of the code, and each other. Don’t hard code every choice, and maybe allow changing a few at runtime. Don’t try to do all of these things at the same time, and maybe don’t write so much code in the first place.</p>
<h4 id="step-0-dont-write-code">Step 0: Don’t write code</h4>
<p>The number of lines of code doesn’t tell us much on its own, but the magnitude does 50, 500 5,000, 10,000, 25,000, etc. A million line monolith is going to be more annoying than a ten thousand line one and significantly more time, money, and effort to replace.</p>
<p>Although the more code you have the harder it is to get rid of, saving one line of code saves absolutely nothing on its own.</p>
<p>Even so, the easiest code to delete is the code you avoided writing in the first place.</p>
<h4 id="step-1-copy-paste-code">Step 1: Copy-paste code</h4>
<p>Building reusable code is something that’s easier to do in hindsight with a couple of examples of use in the code base, than foresight of ones you might want later. On the plus side, you’re probably re-using a lot of code already by just using the file-system, why worry that much? A little redundancy is healthy.</p>
<p>It’s good to copy-paste code a couple of times, rather than making a library function, just to get a handle on how it will be used. Once you make something a shared API, you make it harder to change.</p>
<p>The code that calls your function will rely on both the intentional and the unintentional behaviours of the implementation behind it. The programmers using your function will not rely on what you document, but what they observe.</p>
<p>It’s simpler to delete the code inside a function than it is to delete a function.</p>
<h4 id="step-2-dont-copy-paste-code">Step 2: Don’t copy paste code</h4>
<p>When you’ve copy and pasted something enough times, maybe it’s time to pull it up to a function. This is the “save me from my standard library” stuff: the “open a config file and give me a hash table”, “delete this directory”. This includes functions without any state, or functions with a little bit of global knowledge like environment variables. The stuff that ends up in a file called “util”.</p>
<p>Aside: Make a util directory and keep different utilities in different files. A single util file will always grow until it is too big and yet too hard to split apart. Using a single util file is unhygienic.</p>
<p>The less specific the code is to your application or project, the easier they are to re-use and the less likely to change or be deleted. Library code like logging, or third party APIs, file handles, or processes. Other good examples of code you’re not going to delete are lists, hash tables, and other collections. Not because they often have very simple interfaces, but because they don’t grow in scope over time.</p>
<p>Instead of making code easy-to-delete, we are trying to keep the hard-to-delete parts as far away as possible from the easy-to-delete parts.</p>
<h4 id="step-3-write-more-boilerplate">Step 3: Write more boilerplate</h4>
<p>Despite writing libraries to avoid copy pasting, we often end up writing a lot more code through copy paste to use them, but we give it a different name: boilerplate. Boiler plate is a lot like copy-pasting, but you change some of the code in a different place each time, rather than the same bit over and over.</p>
<p>Like with copy paste, we are duplicating parts of code to avoid introducing dependencies, gain flexibility, and pay for it in verbosity.</p>
<p>Libraries that require boilerplate are often stuff like network protocols, wire formats, or parsing kits, stuff where it’s hard to interweave policy (what a program should do), and protocol (what a program can do) together without limiting the options. This code is hard to delete: it’s often a requirement for talking to another computer or handling different files, and the last thing we want to do is litter it with business logic.</p>
<p>This is not an exercise in code reuse: we’re trying keep the parts that change frequently, away from the parts that are relatively static. Minimising the dependencies or responsibilities of library code, even if we have to write boilerplate to use it.</p>
<p>You are writing more lines of code, but you are writing those lines of code in the easy-to-delete parts.</p>
<h4 id="step-4-dont-write-boilerplate">Step 4: Don’t write boilerplate</h4>
<p>Boilerplate works best when libraries are expected to cater to all tastes, but sometimes there is just too much duplication. It’s time to wrap your flexible library with one that has opinions on policy, workflow, and state. Building simple-to-use APIs is about turning your boilerplate into a library.</p>
<p>This isn’t as uncommon as you might think: One of the most popular and beloved python http clients, requests, is a successful example of providing a simpler interface, powered by a more verbose-to-use library urllib3 underneath. requests caters to common workflows when using http, and hides many practical details from the user. Meanwhile, urllib3 does the pipelining, connection management, and does not hide anything from the user.</p>
<p>It is not so much that we are hiding detail when we wrap one library in another, but we are separating concerns: requests is about popular http adventures, urllib3 is about giving you the tools to choose your own adventure.</p>
<p>I’m not advocating you go out and create a /protocol/ and a /policy/ directory, but you do want to try and keep your util directory free of business logic, and build simpler-to-use libraries on top of simpler-to-implement ones. You don’t have to finish writing one library to start writing another atop.</p>
<p>It’s often good to wrap third party libraries too, even if they aren’t protocol-esque. You can build a library that suits your code, rather than lock in your choice across the project. Building a pleasant to use API and building an extensible API are often at odds with each other.</p>
<p>This split of concerns allows us to make some users happy without making things impossible for other users. Layering is easiest when you start with a good API, but writing a good API on top of a bad one is unpleasantly hard. Good APIs are designed with empathy for the programmers who will use it, and layering is realising we can’t please everyone at once.</p>
<p>Layering is less about writing code we can delete later, but making the hard to delete code pleasant to use (without contaminating it with business logic).</p>
<h4 id="step-5-write-a-big-lump-of-code">Step 5: Write a big lump of code</h4>
<p>You’ve copy-pasted, you’ve refactored, you’ve layered, you’ve composed, but the code still has to do something at the end of the day. Sometimes it’s best just to give up and write a substantial amount of trashy code to hold the rest together.</p>
<p>Business logic is code characterised by a never ending series of edge cases and quick and dirty hacks. This is fine. I am ok with this. Other styles like ‘game code’, or ‘founder code’ are the same thing: cutting corners to save a considerable amount of time.</p>
<p>The reason? Sometimes it’s easier to delete one big mistake than try to delete 18 smaller interleaved mistakes. A lot of programming is exploratory, and it’s quicker to get it wrong a few times and iterate than think to get it right first time.</p>
<p>This is especially true of more fun or creative endeavours. If you’re writing your first game: don’t write an engine. Similarly, don’t write a web framework before writing an application. Go and write a mess the first time. Unless you’re psychic you won’t know how to split it up.</p>
<p>Monorepos are a similar tradeoff: You won’t know how to split up your code in advance, and frankly one large mistake is easier to deploy than 20 tightly coupled ones.</p>
<p>When you know what code is going to be abandoned soon, deleted, or easily replaced, you can cut a lot more corners. Especially if you make one-off client sites, event web pages. Anything where you have a template and stamp out copies, or where you fill in the gaps left by a framework.</p>
<p>I’m not suggesting you write the same ball of mud ten times over, perfecting your mistakes. To quote Perlis: “Everything should be built top-down, except the first time”. You should be trying to make new mistakes each time, take new risks, and slowly build up through iteration.</p>
<p>Becoming a professional software developer is accumulating a back-catalogue of regrets and mistakes. You learn nothing from success. It is not that you know what good code looks like, but the scars of bad code are fresh in your mind.</p>
<p>Projects either fail or become legacy code eventually anyway. Failure happens more than success. It’s quicker to write ten big balls of mud and see where it gets you than try to polish a single turd.</p>
<p>It’s easier to delete all of the code than to delete it piecewise.</p>
<h4 id="step-6-break-your-code-into-pieces">Step 6: Break your code into pieces</h4>
<p>Big balls of mud are the easiest to build but the most expensive to maintain. What feels like a simple change ends up touching almost every part of the code base in an ad-hoc fashion. What was easy to delete as a whole is now impossible to delete piecewise.</p>
<p>In the same we have layered our code to separate responsibilities, from platform specific to domain specific, we need to find a means to tease apart the logic atop.</p>
<blockquote>
<p>[Start] with a list of difficult design decisions or design decisions which are likely to change. Each module is then designed to hide such a decision from the others. D. Parnas</p>
</blockquote>
<p>Instead of breaking code into parts with common functionality, we break code apart by what it does not share with the rest. We isolate the most frustrating parts to write, maintain, or delete away from each other.</p>
<p>We are not building modules around being able to re-use them, but being able to change them.</p>
<p>Unfortunately, some problems are more intertwined and hard to separate than others. Although the single responsibility principle suggests that ‘each module should only handle one hard problem’, it is more important that ‘each hard problem is only handled by one module’</p>
<p>When a module does two things, it is usually because changing one part requires changing the other. It is often easier to have one awful component with a simple interface, than two components requiring a careful co-ordination between them.</p>
<blockquote>
<p>I shall not today attempt further to define the kinds of material I understand to be embraced within that shorthand description [”loose coupling”], and perhaps I could never succeed in intelligibly doing so. But I know it when I see it, and the code base involved in this case is not that. SCOTUS Justice Stewart</p>
</blockquote>
<p>A system where you can delete parts without rewriting others is often called loosely coupled, but it’s a lot easier to explain what one looks like rather than how to build it in the first place.</p>
<p>Even hardcoding a variable once can be loose coupling, or using a command line flag over a variable. Loose coupling is about being able to change your mind without changing too much code.</p>
<p>For example, Microsoft Windows has internal and external APIs for this very purpose. The external APIs are tied to the lifecycle of desktop programs, and the internal API is tied to the underlying kernel. Hiding these APIs away gives Microsoft flexibility without breaking too much software in the process.</p>
<p>HTTP has examples of loose coupling too: Putting a cache in front of your HTTP server. Moving your images to a CDN and just changing the links to them. Neither breaks the browser.</p>
<p>HTTP’s error codes are another example of loose coupling: common problems across web servers have unique codes. When you get a 400 error, doing it again will get the same result. A 500 may change. As a result, HTTP clients can handle many errors on the programmers behalf.</p>
<p>How your software handles failure must be taken into account when decomposing it into smaller pieces. Doing so is easier said than done.
Erlang/OTP is relatively unique in how it chooses to handle failure: supervision trees. Roughly, each process in an Erlang system is started by and watched by a supervisor. When a process encounters a problem, it exits. When a process exits, it is restarted by the supervisor.</p>
<p>(These supervisors are started by a bootstrap process, and when a supervisor encounters a fault, it is restarted by the bootstrap process)</p>
<p>The key idea is that it is quicker to fail-fast and restart than it is to handle errors. Error handling like this may seem counter-intuitive, gaining reliability by giving up when errors happen, but turning things off-and-on again has a knack for suppressing transient faults.</p>
<p>Error handling, and recovery are best done at the outer layers of your code base. This is known as the end-to-end principle. The end-to-end principle argues that it is easier to handle failure at the far ends of a connection than anywhere in the middle. If you have any handling inside, you still have to do the final top level check. If every layer atop must handle errors, so why bother handling them on the inside?</p>
<p>Error handling is one of the many ways in which a system can be tightly bound together. There are many other examples of tight coupling, but it is a little unfair to single one out as being badly designed. Except for IMAP.</p>
<p>In IMAP almost every each operation is a snowflake, with unique options and handling. Error handling is painful: errors can come halfway through the result of another operation.</p>
<p>Instead of UUIDs, IMAP generates unique tokens to identify each message. These can change halfway through the result of an operation too. Many operations are not atomic. It took more than 25 years to get a way to move email from one folder to another that reliably works. There is a special UTF-7 encoding, and a unique base64 encoding too.</p>
<p>I am not making any of this up.</p>
<p>By comparison, both file systems and databases make much better examples of remote storage. With a file system, you have a fixed set of operations, but a multitude of objects you can operate on.</p>
<p>Although SQL may seem like a much broader interface than a filesystem, it follows the same pattern. A number of operations on sets, and a multitude of rows to operate on. Although you can’t always swap out one database for another, it is easier to find something that works with SQL over any homebrew query language.</p>
<p>Other examples of loose coupling are other systems with middleware, or filters and pipelines. For example, Twitter’s Finagle uses a common API for services, and this allows generic timeout handling, retry mechanisms, and authentication checks to be added effortlessly to client and server code.</p>
<p>(I’m sure if I didn’t mention the UNIX pipeline here someone would complain at me)</p>
<p>First we layered our code, but now some of those layers share an interface: a common set of behaviours and operations with a variety of implementations. Good examples of loose coupling are often examples of uniform interfaces.</p>
<p>A healthy code base doesn’t have to be perfectly modular. The modular bit makes it way more fun to write code, in the same way that Lego bricks are fun because they all fit together. A healthy code base has some verbosity, some redundancy, and just enough distance between the moving parts so you won’t trap your hands inside.</p>
<p>Code that is loosely coupled isn’t necessarily easy-to-delete, but it is much easier to replace, and much easier to change too.</p>
<p>####Step 7: Keep writing code
Being able to write new code without dealing with old code makes it far easier to experiment with new ideas. It isn’t so much that you should write microservices and not monoliths, but your system should be capable of supporting one or two experiments atop while you work out what you’re doing.</p>
<p>Feature flags are one way to change your mind later. Although feature flags are seen as ways to experiment with features, they allow you to deploy changes without re-deploying your software.</p>
<p>Google Chrome is a spectacular example of the benefits they bring. They found that the hardest part of keeping a regular release cycle, was the time it took to merge long lived feature branches in.</p>
<p>By being able to turn the new code on-and-off without recompiling, larger changes could be broken down into smaller merges without impacting existing code. With new features appearing earlier in the same code base, it made it more obvious when long running feature developement would impact other parts of the code.</p>
<p>A feature flag isn’t just a command line switch, it’s a way of decoupling feature releases from merging branches, and decoupling feature releases from deploying code. Being able to change your mind at runtime becomes increasingly important when it can take hours, days, or weeks to roll out new software. Ask any SRE: Any system that can wake you up at night is one worth being able to control at runtime.</p>
<p>It isn’t so much that you’re iterating, but you have a feedback loop. It is not so much you are building modules to re-use, but isolating components for change. Handling change is not just developing new features but getting rid of old ones too. Writing extensible code is hoping that in three months time, you got everything right. Writing code you can delete is working on the opposite assumption.</p>
<p>The strategies i’ve talked about — layering, isolation, common interfaces, composition — are not about writing good software, but how to build software that can change over time.</p>
<blockquote>
<p>The management question, therefore, is not whether to build a pilot system and throw it away. You will do that. […] Hence plan to throw one away; you will, anyhow. Fred Brooks</p>
</blockquote>
<p>You don’t need to throw it all away but you will need to delete some of it. Good code isn’t about getting it right the first time. Good code is just legacy code that doesn’t get in the way.</p>
<p>Good code is easy to delete.</p>
<p>Acknowledgments
Thank you to all of my proof readers for your time, patience, and effort</p>
]]></content>
        </item>
        
        <item>
            <title>Critical Ingredient to Become a Genius</title>
            <link>https://nhwaani.github.io/posts/2020/04/critical-ingredient-to-become-a-genius/</link>
            <pubDate>Fri, 03 Apr 2020 16:15:18 +0400</pubDate>
            
            <guid>https://nhwaani.github.io/posts/2020/04/critical-ingredient-to-become-a-genius/</guid>
            <description>Everyone knows that to do great work you need both natural ability and determination. But there’s a third ingredient that’s not as well understood: an obsessive interest in a particular topic
To explain this point I need to burn my reputation with some group of people, and I’m going to choose bus ticket collectors. There are people who collect old bus tickets. Like many collectors, they have an obsessive interest in the minutiae of what they collect.
They can keep track of distinctions between different types of bus tickets that would be hard for the rest of us to remember. Because we don’t care enough. What’s the point of spending so much time thinking about old bus tickets?
Which leads us to the second feature of this kind of obsession: there is no point. A bus ticket collector’s love is disinterested. They’re not doing it to impress us or to make themselves rich, but for its own sake
When you look at the lives of people who’ve done great work, you see a consistent pattern. They often begin with a bus ticket collector’s obsessive interest in something that would have seemed pointless to most of their contemporaries. One of the most striking features of Darwin’s book about his voyage on the Beagle is the sheer depth of his interest in natural history.</description>
            <content type="html"><![CDATA[<p>Everyone knows that to do great work you need both natural ability and determination. But there’s a third ingredient that’s not as well understood:
<strong><em>an obsessive interest in a particular topic</em></strong></p>
<p>To explain this point I need to burn my reputation with some group of people, and I’m going to choose bus ticket collectors. There are people who collect old bus tickets. Like many collectors, they have an obsessive interest in the minutiae of what they collect.</p>
<p>They can keep track of distinctions between different types of bus tickets that would be hard for the rest of us to remember. Because we don’t care enough. What’s the point of spending so much time thinking about old bus tickets?</p>
<p>Which leads us to the second feature of this kind of obsession: there is no point. A bus ticket collector’s love is disinterested. They’re not doing it to impress us or to make themselves rich, but for its own sake</p>
<p>When you look at the lives of people who’ve done great work, you see a consistent pattern. They often begin with a bus ticket collector’s obsessive interest in something that would have seemed pointless to most of their contemporaries. One of the most striking features of Darwin’s book about his voyage on the Beagle is the sheer depth of his interest in natural history. His curiosity seems infinite. Ditto for Ramanujan, sitting by the hour working out on his slate what happens to series.</p>
<p>It’s a mistake to think they were “laying the groundwork” for the discoveries they made later. There’s too much intention in that metaphor. Like bus ticket collectors, they were doing it because they liked it.</p>
<p>But there is a difference between Ramanujan and a bus ticket collector. Series matter and bus tickets don’t.</p>
<blockquote>
<p>If I had to put the recipe for genius into one sentence, that might be it:
to <strong>have a disinterested obsession with something that matters</strong></p>
</blockquote>
<p>Aren’t I forgetting about the other two ingredients? Less than you might think. An obsessive interest in a topic is both a proxy for ability and a substitute for determination. Unless you have sufficient mathematical aptitude, you won’t find series interesting. And when you’re obsessively interested in something, you don’t need as much determination: <strong>you don’t need to push yourself as hard when curiosity is pulling you.</strong></p>
<p>An obsessive interest will even bring you luck, to the extent anything can. Chance, as Pasteur said, favors the prepared mind, and if there’s one thing an obsessed mind is, it’s prepared.</p>
<p>The disinterestedness of this kind of obsession is its most important feature. Not just because it’s a filter for earnestness, but because it helps you discover new ideas.</p>
<p>The paths that lead to new ideas tend to look unpromising. If they looked promising, other people would already have explored them. How do the people who do great work discover these paths that others overlook? The popular story is that they simply have a better vision: because they’re so talented, they see paths that others miss. But if you look at the way great discoveries are made, that’s not what happens. Darwin didn’t pay closer attention to individual species than other people because he saw that this would lead to great discoveries, and they didn’t. He was just really, really interested in such things.</p>
<p>Darwin couldn’t turn it off. Neither could Ramanujan. They didn’t discover the hidden paths that they did because they seemed promising, but because they couldn’t help it. That’s what allowed them to follow paths that someone who was merely ambitious would have ignored.</p>
<p>What rational person would decide that the way to write great novels was to begin by spending several years creating an imaginary elvish language, like Tolkien, or visiting every household in southwestern Britain, like Trollope? No one, including Tolkien and Trollope.</p>
<p><code>The bus ticket theory is similar to Carlyle’s famous definition of genius as an infinite capacity for taking pains. But there are two differences. The bus ticket theory makes it clear that the source of this infinite capacity for taking pains is not infinite diligence, as Carlyle seems to have meant, but the sort of infinite interest that collectors have. It also adds an important qualification: an infinite capacity for taking pains about something that matters.</code></p>
<p>So what matters? You can never be sure. It’s precisely because no one can tell in advance which paths are promising that you can discover new ideas by working on what you’re interested in. But there are some heuristics you can use to guess whether an obsession might be one that matters. For example, it’s more promising if you’re creating something, rather than just consuming something someone else creates.</p>
<p>It’s more promising if something you’re interested in is difficult, especially if it’s more difficult for other people than it is for you. And the obsessions of talented people are more likely to be promising. When talented people become interested in random things, they’re not truly random.</p>
<p>But you can never be sure. In fact, here’s an interesting idea that’s also rather alarming if it’s true: it may be that to do great work, you also have to waste a lot of time. In many different areas, reward is proportionate to risk. If that rule holds here, then the way to find paths that lead to truly great work is to be willing to expend a lot of effort on things that turn out to be every bit as unpromising as they seem.</p>
<p>I’m not sure if this is true. On one hand, it seems surprisingly difficult to waste your time so long as you’re working hard on something interesting. So much of what you do ends up being useful. But on the other hand, the rule about the relationship between risk and reward is so powerful that it seems to hold wherever risk occurs. Newton’s case, at least, suggests that the risk/reward rule holds here.</p>
<p>He’s famous for one particular obsession of his that turned out to be unprecedentedly fruitful: using math to describe the world. But he had two other obsessions, alchemy and theology, that seem to have been complete wastes of time. He ended up net ahead. His bet on what we now call physics paid off so well that it more than compensated for the other two. But were the other two necessary, in the sense that he had to take big risks to make such big discoveries? I don’t know.</p>
<p>Here’s an even more alarming idea: might one make all bad bets? It probably happens quite often. But we don’t know how often, because these people don’t become famous.</p>
<p>It’s not merely that the returns from following a path are hard to predict. They change dramatically over time. 1830 was a really good time to be obsessively interested in natural history. If Darwin had been born in 1709 instead of 1809, we might never have heard of him.</p>
<p>What can one do in the face of such uncertainty? One solution is to hedge your bets, which in this case means to follow the obviously promising paths instead of your own private obsessions. But as with any hedge, you’re decreasing reward when you decrease risk.</p>
<p>If you forgo working on what you like in order to follow some more conventionally ambitious path, you might miss something wonderful that you’d otherwise have discovered. That too must happen all the time, perhaps even more often than the genius whose bets all fail.</p>
<p>The other solution is to let yourself be interested in lots of different things. You don’t decrease your upside if you switch between equally genuine interests based on which seems to be working so far. But there is a danger here too: if you work on too many different projects, you might not get deeply enough into any of them.</p>
<p>One interesting thing about the bus ticket theory is that it may help explain why different types of people excel at different kinds of work. Interest is much more unevenly distributed than ability. If the natural ability is all you need to do great work, and natural ability is evenly distributed, you have to invent elaborate theories to explain the skewed distributions we see among those who actually do great work in various fields. But it may be that much of the skew has a simpler explanation: different people are interested in different things.</p>
<p>The bus ticket theory also explains why people are less likely to do great work after they have children. Here interest has to compete not just with external obstacles, but with another interest, and one that for most people is extremely powerful. It’s harder to find time for work after you have kids, but that’s the easy part. The real change is that you don’t want to.</p>
<p>But the most exciting implication of the bus ticket theory is that it suggests ways to encourage great work. If the recipe for genius is simply natural ability plus hard work, all we can do is hope we have a lot of ability, and work as hard as we can. But if interest is a critical ingredient in genius, we may be able, by cultivating interest, to cultivate genius.</p>
<p>For example, for the very ambitious, the bus ticket theory suggests that the way to do great work is to relax a little. Instead of gritting your teeth and diligently pursuing what all your peers agree is the most promising line of research, maybe you should try doing something just for fun. And if you’re stuck, that may be the vector along which to break out.</p>
<p>I’ve always liked Hamming’s famous double-barrelled question: what are the most important problems in your field, and why aren’t you working on one of them? It’s a great way to shake yourself up. But it may be overfitting a bit. It might be at least as useful to ask yourself: if you could take a year off to work on something that probably wouldn’t be important but would be really interesting, what would it be?</p>
<p>The bus ticket theory also suggests a way to avoid slowing down as you get older. Perhaps the reason people have fewer new ideas as they get older is not simply that they’re losing their edge. It may also be because once you become established, you can no longer mess about with irresponsible side projects the way you could when you were young and no one cared what you did.</p>
<p>The solution to that is obvious: remain irresponsible. It will be hard, though, because the apparently random projects you take up to stave off decline will read to outsiders as evidence of it. And you yourself won’t know for sure that they’re wrong. But it will at least be more fun to work on what you want.</p>
<p>It may even be that we can cultivate a habit of intellectual bus ticket collecting in kids. The usual plan in education is to start with a broad, shallow focus, then gradually become more specialized. But I’ve done the opposite with my kids. I know I can count on their school to handle the broad, shallow part, so I take them deep.</p>
<p>When they get interested in something, however random, I encourage them to go preposterously, bus ticket collectorly, deep. I don’t do this because of the bus ticket theory. I do it because I want them to feel the joy of learning, and they’re never going to feel that about something I’m making them learn. It has to be something they’re interested in. I’m just following the path of least resistance; depth is a byproduct. But if in trying to show them the joy of learning I also end up training them to go deep, so much the better.</p>
<p>Will it have any effect? I have no idea. But that uncertainty may be the most interesting point of all. There is so much more to learn about how to do great work. As old as human civilization feels, it’s really still very young if we haven’t nailed something so basic. It’s exciting to think there are still discoveries to make about discovery. If that’s the sort of thing you’re interested in.</p>
]]></content>
        </item>
        
    </channel>
</rss>
